\section{Synchronization}
\label{sec:collaboration}


%\subsection{Synchronization in case of concurrent modifications}
In our previous work [XX], a methodological pattern is proposed to synchronize model and object-oriented code in case of concurrent modifications made in the model and code.
The pattern especially requires the availability of several use-cases as followings:
\begin{itemize}
	\item \tb{Batch code generation}: generates and overwrites any existing code from model.
	\item \tb{Incremental code generation}: updates the code by propagating changes from the model to the code.
	\item \tb{Batch reverse engineering}: creates and overwrites any existing model from code.
	\item \tb{Incremental reverse engineering}: updates the model by propagating changes from the code to the model.
\end{itemize}


The batch code generation and reverse engineering are straightforwardly supported by using the bidirectional traceability between the architecture model and code created by XSeparation. The incremental code generation (ICG) and incremental reverse engineering (IRE) needs a classification and management of modifications made in the model and code.

\vskip 0.2cm
\noindent
\tb{Model modification classification and management:}
Table \ref{table:modelchangeclassification} shows our classification and management of actions for propagating modifications in model to code.
They can be detected by a model listener.
We make a distinction between structural and behavioral modifications, which result in creating/removing/regenerating the corresponding code part.
Although only add/remove/update are detected, the moving of a model element can be combined as a removal following by an addition.  
Some particular modifications requires the corresponding actions to respect and preserve the user code.
For example, if the \ttt{sendDataToFifo} method in Listing \ref{lst:producerinteraction} is renamed to \ttt{sendDataFromProducerToFifo} at the model level, the corresponding action consists of several steps: (1) identify the method, at the code level, associated with the operation, at the model level, using the old name \ttt{sendDataToFifo}, which is recorded by the model listener;
(2) rename the method to \ttt{sendDataFromProducerToFifo} while keeping its parameters and body intact. 

\vskip 0.2cm
\noindent
\tb{Code modification classification and management:}
Modifications types in code are similar to that of model consisting of structural and behavioral modifications.
However, we do not support the removal of classes in code because this kind of modification causes conflicts and syntax errors, which require the code to be manually re-factored for reconciliation. 
We believe that an automatic mechanism brought by the regeneration of code caused by the removal can better handle the refactoring.
If the FIFO class is removed in the code, for example, the \ttt{fifo} in \ttt{System} in Listing \ref{lst:architectureprescribed} must be retyped or removed.
If not, a compilation error is raised.
% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table*}[]
	\centering
	\caption{Model change classification and management}
	\label{table:modelchangeclassification}
	\begin{tabular}{|l|p{3cm}|l|p{9.5cm}|}
		\hline
		\multicolumn{2}{|c|}{Element type}                                                              & \multicolumn{1}{c|}{Modification type} & \multicolumn{1}{c|}{Action}                                                                              \\ \hline
		\multirow{3}{*}{Structure} & Part/Port/Connector                                                                & Add/Remove/Update                & Regenerate Component structure-prescribed code                                                                                          \\ \cline{2-4} 
		& Class/Component/Interface                                          & Add/Remove/Update                & Create/Remove/Update the corresponding code                                                              \\ \cline{2-4} 
		& Property                                                           & Add/Remove/Update                & Create/Remove/Regenerate the corresponding class attribute                                               \\ \hline
		\multirow{5}{*}{Behavior}  & Operation                                                          & Add/Remove/Update                & Create/Remove/Regenerate the corresponding method with keeping its method body                           \\ \cline{2-4} 
		& \multirow{3}{*}{UML State Machine}                                 & Create                           & Generate Behavior-prescribed code and State machine action code                                          \\ \cline{3-4} 
		&                                                                    & Remove                           & Remove Behavior-prescribed code and State machine action code from the corresponding component           \\ \cline{3-4} 
		&                                                                    & Update                           & Regenerate Behavior-prescribed code and State machine action code with respect to the existing user-code \\ \cline{2-4} 
		& UML State Machine concept (state, transition, pseudo state, event) & Create/Remove/Update             & Regenerate Behavior-prescribed code and State machine action code with respect to the existing user-code \\ \hline
	\end{tabular}
\end{table*}

Using these use-cases and the bidirectional traceability facilitated by XSeparation during code generation, the concurrent modifications in model and code can be synchronized by our previous methodological pattern.

After synchronization, to be executable, the XSeparation-generated code needs to be compiled.
In the next section, we will present the architecture of our XSeparation compiler for compilation. 

%\input{sections/mappingtable}

%\input{sections/oldsynchronization}
%\input{sections/synchronizationexample}
