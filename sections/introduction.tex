\section{Introduction}
\label{sec:intro}
%Unified Modeling Language (UML) State Machines (USMs) and their visualizations are suitable to model and design event-driven architecture-based embedded systems.
%The latter are usually resource-constrained.
%USMs can be used by the code generation technology in Model-Driven Engineering (MDE).
%The latter is considered as an efficient methodology to deal with system complexity.


%The so-called Model-Driven Engineering (MDE) approach relies on two paradigms, abstraction and automation \cite{Mussbacher2014}. It is recognized as very efficient for dealing with complexity of today's systems. 
%Abstraction is the ability to provide simplified and focused view of a system and requires adequate modeling language. 
%Unified Modeling Language (UML) \cite{Specification2007} is nowadays the most used, educated, and documented modeling language. 
%Even, if a graphical language such as Unified Modeling Language (UML) \cite{Specification2007} is not the silver bullet for all software related concerns, it provides hence better support than text-based solutions for some concerns such as architecture and logical behavior of application development. 
%Abstraction provides simplified and focused views of a system and requires adequate graphical modeling languages such as Unified Modeling Language (UML). %Even, if the latter is not the silver bullet for all software related concerns, 
%The latter provides better support than text-based solutions for some concerns such as architecture and logical behavior of application development. 

%Event-driven architecture is used for . 
UML state machines (USMs) and their visual representations are efficient to describe, analyze and implement high level logic behaviors of event-driven %architecture for designing memory-constrained 
embedded systems \cite{Dunkels:2006:PSE:1182807.1182811}. 
A number of code generation approaches and industrial tools have been proposed in the context of Model-Driven Engineering (MDE) \cite{kent2002model} to automate the process of translating USMs into implementation \cite{possepapyrusrt, Booch1998, Douglass1999,Shalyto2006,Douglass1999, ibm_rhapsody, sinelabore, qm}.  

Ideally, a full model-centric approach is preferred by MDE community due to its advantages \cite{Selic2012}. 
However, in industrial practice, there is significant reticence \cite{Hutchinson:2011:MEP:1985793.1985882} to adopt it.
On one hand, programmers prefer to
use the more familiar programming language. 
On the other hand, software architects, working at higher levels
of abstraction, favor the use of models, and therefore
prefer graphical languages for describing the system architecture high level logic behavior \cite{Hutchinson:2011:MEP:1985793.1985882,Hutchinson:2011:EAM:1985793.1985858}.

%The surveys described in \cite{Hutchinson:2011:MEP:1985793.1985882} and \cite{Hutchinson:2011:EAM:1985793.12985858} polled MDE practitioners. 
%It notes that 70\% of the respondents primarily work with models, but still require manually-written code to be integrated.
%Furthermore, 35\% of the respondents answered that they spend a lot of time and effort synchronizing model and code.

%However, on the one hand, maintaining code generated from existing approaches is non-trivial. On the other hand our observation is that it is very difficult to come up with formalizations that yield such elegant code generation solutions \cite{6032552}. In other words, generated code must be manually modified to build fully operational applications. 
%On one hand there are traditional developers who prefer to implement the system by writing code, while on the other hand there are developers who prefer to use entirely models for the design and implementation of the system. 

The back-and-forth switching between between model and code raises the consistency and synchronization problem.
%The code modified by programmers and the model are then inconsistent. 
Round-trip engineering (RTE) \cite{Hettel2008} is proposed to synchronize different software artifacts, model and code in this case \cite{Sendall}. 
RTE enables actors (software architect and programmers) to freely move between different representations and stay efficient with their favorite working environment. 
In other words, RTE enables both model and code to be considered as development artifact. 

%After code modifications, round-trip engineering (RTE) is needed to make the model and code consistent, which is a critical aspect to meet quality and performance constraint required from project managers today. 

Approaches proposed for RTE are categorized as \ti{structure} and \ti{behavior} RTE.
The former refers to synchronization of structural concepts such as those available from class diagrams and code, and is supported by industrial tools such as IBM Rhapsody \cite{ibm_rhapsody} and Enterprise Architect \cite{sparxsystems_enterprise_2014}.
Some approaches such as \cite{langhammer2013co, kramer2015change} allow the co-evolution of component-based diagram elements and code.

The \ti{behavior} RTE is usually supported very limitedly. 
This is because there is no trivial mapping from behavior model such as USM and code.
Consequently, it is very difficult to reflect behavior code changes to the original model.
Approaches for the \ti{behavior} RTE often allow programmers to partially modify behavioral code in limited areas by separating the \ttt{generated} and \ttt{non-generated code} \cite{ibm_rhapsody,steinberg2008emf} using some specialized comments such as \ttt{@generated NOT}.
Approaches and tools in this category use an incremental code generation, which preserves the user-code changes in the areas marked as non-generated.
However, "\ti{current separation mechanisms require the programmers are highly discipline.
Furthermore, even so, accidental changes are still possible}" \cite{zheng2012enhancing}.


In this paper, we tackle the problem of synchronization between model, which includes both structural and behavioral elements, and \ttt{C++} code, which meets resource-constrained requirements for developing event-driven embedded systems.
Specifically, the system architecture is specified via UML class diagrams and the behavior via USMs.
Component and composite structure diagrams for architecture description will be included in future work.
To support the architects and the programmers at the modeling and programming level, respectively, equivalently, our goal is to allow the synchronization of USMs with full features and code.
The latter should be efficient (small in size and fast in event processing speed) to be fit into resource-constrained systems. 

Our proposed technique \tf{RAOES} is inspired by \ttt{ArchJava} \cite{aldrich2002archjava} and \ttt{Archface} \cite{ubayashi2010archface} whose goal is to allow the co-evolution of architecture and implementation in Java by introducing additional constructs to Java.
Our approach adds USM-based constructs to connect C++ to the USMs.
Instead of directly generating C++ code from models as the existing tools, RAOES produces a C++ front-end code, which contains our added constructs.
The programmers are free to modify not only the high level logic behavior described by USMs but also the user code by making changes to the C++ front-end code.

The introduction of the front-end is similar to \ttt{MSM} \cite{MSM} and \ttt{EUML} \cite{EUML}.
However, these front-ends use a lot of C++ templates, which make the code difficult to write and understand.
Furthermore, they support only a limited subset of USM, especially events defined by UML are not correctly supported.

In RAOES, the C++ front-end is merged into and written in the usual C++ code.
The front-end is then used for generating a back-end code, which is actually used for compilation to binary files.
Furthermore, using our strategy defined in this paper, the front-end code is also synchronized with the model when there are concurrent modifications.

%Unfortunately, current industrial tools such as for instance Enterprise Architect \cite{sparxsystems_enterprise_2014} and IBM Rhapsody\cite{ibm_rhapsody} only support structural concepts for RTE such as those available from class diagrams and code. Compared to RTE of class diagrams and code, RTE of USMs and code is non-trivial. It requires a semantical analysis of the source code, code pattern detection and mapping patterns into USM elements. 
%This is a hard task, since mainstream programming languages such as C++ and JAVA do not have a trivial mapping between USM elements and source code statements.

%For software development, one may wonder whether this RTE is doable. That is, why do the industrial tools not support the propagation of source code modifications back to original state machines? Several possible reasons to this lack are (1) the gap between USMs and code, (2) not every source code modification can be reverse engineered back to the original model, and (3) the penalty of using transformation patterns facilitating the reverse engineering that may not be the most efficient (e.g. a slightly larger memory overhead). 
%in the mind of these tools' vendors, users always make changes to models rather than to code. Generated code, in these tools, is therefore not supposed to be changed directly.  

%In this paper, we address the RTE of UML State Machine diagrams and its related generated code. We propose a RTE approach consisting of a forward process which generates code by using transformation patterns, and a backward process which is based on code pattern detection to update the original state machine model from the modified generated code. From the proposed approach, we implemented a prototype and conducted several experiments on different aspects of the round-trip engineering to verify the proposed approach. 



%Model-driven engineering (MDE) is a development methodology aiming to increase software productivity and quality by allowing different stakeholders to contribute to the system description \cite{Mussbacher2014}. MDE considers models as first-class artifacts and generates code from higher abstraction level models. Recent survey \cite{1030} has revealed that industries are gaining the adoption of code generation into software development life-cycle. Although many tools and research prototypes can generate executable code from models, generated code could be manually modified by programmers, e.g. skeleton code generated from UML \cite{Specification2007} class diagrams. Models and the generated code are therefore out of synchronization. Round-trip engineering \cite{AÃŸmann200333, Hettel2008, E-ESE-120044648} (RTE) is proposed to keep the artifacts synchronized.

%RTE supports synchronizing different software artifacts, model and code in this case, and thus enabling actors (software architect and programmers) to freely move between different representations \cite{Sendall}. Tools such as for instance Enterprise Architect \cite{sparxsystems_enterprise_2014}, Visual Paradigm \cite{visual}, and AndroMDA \cite{_andromda_} provide RTE but most of them are only applicable for system structure models such as class diagrams.  

%This study addresses the RTE of UML State Machine (SM) and object-oriented programming languages such as C++ and JAVA. SM is widely used in practice for modeling the behavior of complex systems, notably reactive, real-time embedded systems. There are several approaches to generating source code from state machines or state charts such as nested switch/if statements \cite{Booch1998}, state-event-table \cite{Douglass1999, Duby2001}, and state pattern \cite{Allegrini2002,Shalyto2006,Douglass1999}. Unfortunately, the generated code from these approaches is very difficult for programmers to maintain without an appropriate supporting tool. RTE is impossible in these approaches even with very small changes such as changing transition targets or actions made to code. The reason behind this impossibility is that, in mainstream programming languages such as C++, JAVA, (1) there are not equivalents between SMs and source code statements and (2) the code generation pattern of these approaches has not been chosen with RTE in mind.

%This paper addresses the RTE of UML state-machines and object-oriented programming languages such as C++ and JAVA. The forward  engineering of the approach takes as input a state-machine and executes two transformations. The first is UML to UML by utilizing several transformation patterns such as the double-dispatch approach presented in \cite{spinke_object-oriented_2013} and the second is a generation of code from the transformed UML. Traceability information is stored, during the transformations. In the backward direction, a verification is executed by the code pattern detection to verify the correctness of the code before the backward process taking as input the modified generated code, the UML classes, the original state-machine and mapping information together merges changes from code to the state-machine. We implemented a prototype supporting RTE of state-machine and C++ code, and conducted several experiments on different aspects of the RTE to verify the proposed approach. To the best of our knowledge, our implementation is the first tool supporting RTE of SM and code. 
%The prototype also improves the collaboration between MDE developers and traditional programmers in developing reactive complex embedded systems.

%This paper addresses the RTE of USMs and object-oriented programming languages such as C++ and JAVA. The main idea is to utilize transformation patterns from USMs to source code that aggregates code segments associated with a USM element into source code methods/classes rather than scatters these segments in different places. Therefore, the reverse direction of the RTE can easily statically analyze the generated code by using code pattern detection and maps the code segments back to USM elements. Specifically, in the forward direction, we extend the double dispatch pattern presented in \cite{spinke_object-oriented_2013}. Traceability information is stored during the transformations. We implemented a prototype supporting RTE of state-machine and C++ code, and conducted several experiments on different aspects of the RTE to verify the proposed approach. To the best of our knowledge, our implementation is the first tool supporting RTE of SM and code. 

To sum up, our contribution is as followings:
\begin{itemize}
	\item RAOES: A round-trip engineering approach for developing event-driven systems using UML State Machines and C++.
	\item The implementation of RAOES based on the Eclipse Modeling Framework (EMF) and the Papyrus tool.
	\item Experimental evaluations by experimenting with RAOES and a case study simulation.
	%\begin{itemize}
		%\item An automatic evaluation of the proposed RTE approach with the prototype.% including 300 random generated SM models containing 80 states, more than 230 transitions, more than 250 actions and around 180 events for each.
		%\item A complexity analysis of the approach and performance evaluation.
		%\item A comparison and collaboration of two software development practices including working at the model level and at the code level.
		%\item A lightweight evaluation of the semantic conformance of the runtime execution of generated code.
	%\end{itemize}
\end{itemize}

Even though this presented work is specific to C++ and embedded systems, the general idea can be applied to other object-oriented programming languages such as Java and to other domains.

The remainder of this paper is organized as follows: Section \ref{sec:background} presents the background. 
Section \ref{sec:motivation} and \ref{sec:overview} describe the motivation and overview of RAOES. 
The syntax of RAOES's front-end is detailed in Section \ref{sec:syntax}.
Section \ref{sec:collaboration} shows RAOES's synchronization strategy.
The implementation of RAOES is described in Section \ref{sec:implementation}. 
Section \ref{sec:exp} presents our research questions to evaluate RAOES. 
A simulation case study of a Traffic Light Controller in Section \ref{sec:casestudy} is used to show the practicality of RAOES.  
Section \ref{sec:relatedwork} shows related work. 
The conclusion and future work are presented in Section \ref{sec:conclusion}.

