\section{Introduction}
\label{sec:intro}
%Unified Modeling Language (UML) State Machines (USMs) and their visualizations are suitable to model and design event-driven architecture-based embedded systems.
%The latter are usually resource-constrained.
%USMs can be used by the code generation technology in Model-Driven Engineering (MDE).
%The latter is considered as an efficient methodology to deal with system complexity.





%The so-called Model-Driven Engineering (MDE) approach relies on two paradigms, abstraction and automation \cite{Mussbacher2014}. It is recognized as very efficient for dealing with complexity of today's systems. 
%Abstraction is the ability to provide simplified and focused view of a system and requires adequate modeling language. 
%Unified Modeling Language (UML) \cite{Specification2007} is nowadays the most used, educated, and documented modeling language. 
%Even, if a graphical language such as Unified Modeling Language (UML) \cite{Specification2007} is not the silver bullet for all software related concerns, it provides hence better support than text-based solutions for some concerns such as architecture and logical behavior of application development. 
%Abstraction provides simplified and focused views of a system and requires adequate graphical modeling languages such as Unified Modeling Language (UML). %Even, if the latter is not the silver bullet for all software related concerns, 
%The latter provides better support than text-based solutions for some concerns such as architecture and logical behavior of application development. 
System architecting has become one of the most important tasks during development.
Unified Modeling Language (UML) has been widely used in Model-Driven Engineering (MDE) \cite{Selic2012} and become an industry de factor standard to describe and document architecture of complex systems \cite{hilliard1999using, HUTCHINSON2014144} despite the emergence and disappearance of a number of architecture description languages \cite{pandey2010architectural}.
%An event-driven architecture is useful for designing 
%UML state machines (USMs) and their visual representations are efficient to modeling high level logic behaviors of event-driven embedded software architecture. % for designing memory-constrained 
%embedded systems \cite{Dunkels:2006:PSE:1182807.1182811}.
UML Class, Composite Structure, and State Machine diagrams prove to well capture a reactive system architecture \cite{possepapyrusrt}, which is useful for designing flexible, loosely-coupled and scalable embedded systems \cite{Dunkels:2006:PSE:1182807.1182811,reactivemanifesto}.    
%UML State Machines efficiently describe such architecture behavior \cite{possepapyrusrt,Ringert2013}.
In MDE, implementation can be automatically produced from architecture models specified by the UML models in order to raise software productivity and eliminate bugs \cite{possepapyrusrt}.
%\cite{possepapyrusrt, Douglass1999,Shalyto2006, ibm_rhapsody}.  

%Ideally, a full model-centric approach is preferred by MDE community due to its advantages \cite{Selic2012} such as complexity management, model-based analysis, abstraction, and automation. 
%The ultimate goal of MDE is to create executable models for generating full implementation code.
%However, in industrial practice, there is significant reticence \cite{Hutchinson:2011:MEP:1985793.1985882} to adopt it.


%Model-Driven Engineering (MDE) aims to create executable models for generating full implementation code.
%This aim enables a full model centric-approach, which is preferred by MDE community due to its advantages \cite{Selic2012} such as complex project management, model-based system analysis, abstraction, and automation.

Current UML tools and approaches are not sufficient to exploit the fine-grained behavior of the architecture. 
The approach in \cite{ciccozzi2013towards} uses the Action Language for Foundational UML (ALF) \cite{alfspecification} to express the fine-grained behavior for generating fully operational code.
The approach in \cite{DBLP:conf/date/CharfiMGTB10} even proposes a model compiler, which directly converts ALF code into binary code.
However, ALF is currently not widely used in software development as much as mainstream programming languages such as Java or C++.
Furthermore, with the model compilation, many optimizations at the code level, proposed by many tools and compilers such as GCC, become useless.



Industrial MDE tools such as IBM Rhapsody \cite{ibm_rhapsody} and Papyrus-RT \cite{possepapyrusrt} put manually written fine-grained programming code such as C++, instead of ALF, within the architecture model to generate fully operational code. 
These tools force the programmers to use limited textual editors supported by these tools for manual coding. 
This later practice often lacks programming facilities such as auto-completion appeared in modern integrated development environments (IDEs) and might produce errors during compilation of the generated code with the manual code. 
In such a case the programmers tend to directly modify the generated code for a successful compilation by using a familiar IDE of the programmers. 


In continuous development, the architects might change the architecture for new functionalities or requirements while the programmers might still tailor the current architecture or modify the code for various reasons such as code level optimization for algorithmic/computational code, bug fixing, and refactoring. 
This results that the architecture model and code are concurrently modified. 

%These tools only produce skeleton code \cite{zheng2013classification}, which must then be tailored by programmers for fine-grained and algorithmic code. 
%Furthermore, there is perception gap between diagram-based and textual languages.
%While programmers prefer to use the more familiar combination of a programming language and Integrated Development Environment (IDE), software architects, working at higher levels of abstraction, tend to favor the use of modeling languages for describing the system architecture \cite{foster2016}.

%The modifications in code might violate the architecture correctness.
The modifications made in model and code must be synchronized to make the architecture and code consistent. 
%When the generated code is modified, 
%, the modifications in the code must be reflected back to the model. 
To deal with it, several approaches such as separation \cite{steinberg2008emf} and reverse engineering \cite{ibm_rhapsody} use specialized comments to separate user-modified code and generated code for preserving the user code.
However, these approaches only work for modifications within the user area under assumption that the programmers are highly disciplined \cite{zheng2012enhancing}.
Some tools such as IBM Rhapsody are able to do round-trip engineering: modifications in code can be propagated back to model and vice versa.
However, only UML class diagram concepts are supported by the round-trip engineering tools.
One of the reasons, that makes the propagation of the modifications in the code back to the model hard, is the lack of a bidirectional mapping between the architecture model specified by the aforementioned models and code \cite{ubayashi2010archface}.






%However, on one hand, to generate full code, models must contain very detailed information. 
%Nevertheless, current MDE tools and approaches are not sufficient to describe fine-grained behavior of the architecture. 
%Some MDE tools such as IBM Rhapsody put fine-grained action code within the architecture model as blocks of text to generate full code. 
%However, it is not favorable because the architecture should only hold design decisions. 
%Hence, code generated from the current MDE tools must be tailored by programmers for fine-grained code. 
%Furthermore, it is frequent that programmers modify architecture information during implementation because of abstraction gap between architecture and implementation \cite{ubayashi2010archface}. 
%In these cases the architecture correctness might be violated, which is not easy to detect due to the lack of a bidirectional traceability between the architecture and code. 
%Some approaches \cite{kelly2008domain} prevent modifications in code through complete code generation.
%However, the latter only works for very highly specialized domains and specific architecture styles \cite{zheng2012enhancing}.

%On one hand, it is frequent that programmers modify architecture information during implementation because of abstraction gap between architecture and implementation. %It is not easy to preserve the architecture correctness in implementation. 
%Current industrial MDE tools such as IBM Rhapsody put fine-grained behaviors/computational algorithms directly in the architecture model as blocks of text to generate full code. 
%However, it is %difficult for system analysis and 
%not favorable because the architecture should only hold design decisions. 
%Hence, code generated from the current MDE tools must be tailored by programmers for fine-grained code.
%In this case, the architecture correctness might be violated, which is not easy to detect due to the lack of a bidirectional traceability between the architecture and code \cite{ubayashi2010archface}.
%Some approaches \cite{kelly2008domain} prevent modifications in code through complete code generation.
%However, the latter only works for very highly specialized domains and specific architecture styles \cite{zheng2012enhancing}.

%On the other hand, in software evolution, continuous development and maintenance, the architects might change the architecture for new functionalities or requirements while the programmers might still implement the current architecture or modify the code for various reasons such as code level optimization, bug fixing, refactoring. 

\begin{comment}
In MDE tools, the regeneration of code from the changed architecture would overwrite the modifications made by programmers in code. 
Some tools such as Eclipse Modeling Framework (EMF) \cite{steinberg2008emf} separate code areas, which could be modified by the programmers, to preserve the code changes by using some specialized comments such as \ttt{@generated NOT}.
However, current separation mechanisms require the programmers to be very highly discipline.
Furthermore, even so, accidental changes are still possible \cite{zheng2012enhancing}.
The \ttt{1.x-way architecture mapping deep separation} approach \cite{zheng2012enhancing} overcome the limitations of these separation mechanisms by generating \ttt{architecture-prescribed code} in a class separating from user-code written in an other class.
However, deep separation does not allow to modify the architecture at the code level.
\end{comment}


%If the latter is not solved, modifications in the code are not reflected to the model. Consequently, the model does not reflect the actual running system, which even worse entails that model-based activities such as architecture and behavior analysis, or testing are obsolete, hence many of the advantages of MDE would disappear.
%The modifications made in model and code raise the consistency and synchronization problem \cite{zheng2013classification}.
%If the latter is not solved, modifications in the code are not reflected to the model. 
%As a result, the model does not reflect the actual running system, which even worse entails that model-based activities such as architecture and behavior analysis, or testing are obsolete, hence many of the advantages of MDE would disappear.
%In order to solve this problem, which hinders the adoption of MDE in practice, it is necessary to have a code generation process, which establishes a way to trace code elements back to the model.
%However, current UML tools and approaches cannot synchronize the modifications due to the lack of a bidirectional mapping between architecture model specified by the aforementioned diagrams and code \cite{ubayashi2010archface}.
This paper addresses the synchronization of code and architecture design model specified by the aforementioned UML models. %allows to extremely separate architecture-generated code and user-code. 
%, which consists of structure and behavior models
Our approach consists of a mechanism of bidirectional mapping between the architecture design model and code, and a synchronization mechanism. 
We argue that current programming language elements are at lower level of abstraction than software architectures.
To establish a bidirectional mapping, our approach leverages the abstraction level of an existing object-oriented language by creating additional constructs for expressing architectural information.
Our synchronization mechanism then uses the established mapping mechanism to propagate modifications in code back to model.

%XSeparation provides an adequate support for programmers to control both structure and behavior of a component at the code level. %by making changes in generated architecture-prescribed and state machine-based behavior-prescribed code, respectively.
%XSeparation increases the bidirectional traceability to keep the model and the code consistent. 
%Our goal is to synchronize the system architecture described by UML class and component diagrams and the behavior by UML State Machines with object-oriented code such as C++ and Java.
%These architecture and behavior models, briefly as the design model, are then used for generating code (implementation).
%The code can be modified by programmers while in the meantime the architecture model might be modified by software architects.
%The concurrent modifications raise the problem of consistency between the architecture model and implementation code.

%Synchronization of concurrent modifications made in the architecture model and code is considered as a hard problem because of the abstraction gap between the architecture and the implementation (code). 
%This gap makes the bidirectional traceability, which allows to reflect modifications made in one artifact to the other, between model and code hard, even impossible.


%From a research perspective, this study aims to improve flexibility in MDE to allow the architecture model and the generated code to co-evolve while keeping these two consistent \cite{yu2012maintaining}. 
%Furthermore, R. N. Taylor et al. \cite{Taylor:2007:SDA:1253532.1254721} pointed out an important research direction, in which key design decisions may be made in implementation (code) and evolution of architecture must be seamlessly propagated to the code [5]. 
%This implies the fluid moving from architecture to code and vice versa. Additionally, synchronization of model and code is also considered as an important need by the MODELS community \cite{van2008challenges}.

%For industry, one of the reasons that impede the adoption of MDE is the perceived gap between diagram-based modeling languages and textual languages. On one hand, programmers prefer to use the more familiar combination of a programming language and Integrated Development Environment (IDE). On the other hand, software architects, working at higher levels of abstraction, tend to favor the use of modeling languages for describing the system architecture \cite{foster2016}.


%Our work is motivated by both industry and research.
%From the latter, MDE, for flexibility, allows the architecture model and the generated code to evolve concurrently \cite{yu2012maintaining}.
%Furthermore, R. N. Taylor et al. \cite{Taylor:2007:SDA:1253532.1254721} pointed out an important research direction, in which key design decisions may be made in implementation (code) and evolution of architecture must be seamlessly propagated to the code. 
%This implies the fluid moving from architecture to code and vice versa. 
%Additionally, synchronization of model and code is also considered as an important need by the MODELS community \cite{van2008challenges}.

%Furthermore, as addressed in \cite{zheng2012enhancing}, bidirectional mapping (two-way mapping) between the design model (architecture + behavior model) and the code is the most promising among others such as \ttt{correct-by-detection} and \ttt{one way mapping}.
%This is because the bidirectional mapping provides concurrent modifications made in the design model and the code to foster for software architects and programmers collaboration.

%For industry, one of the reasons that impede the adoption of MDE is the perceived gap between diagram-based modeling languages and textual languages.
%On one hand, programmers prefer to use the more familiar combination of a programming language and Integrated Development Environment (IDE). 
%Text editors
%like Emacs and Vim are also favored by some programmers in
%the embedded Linux community. 
%On the other hand, software architects, working at higher levels of abstraction, tend to favor the use of modeling languages for describing the system architecture.

%In order to provide better support for industry to raise the adoption of MDE synchronization, our goal is to automate the mode-code synchronization in order to maximize the effectiveness of both modeling and programming world \cite{zheng2013classification}.
	
%Software architects, working at a high level abstract, prefer using graphic-based modeling languages for architecture and logic behavior (via UML State Machine) description.
	
%Programmers favor the use of text-based programming languages with their preferred integrated development environment for fine-grained statements and computational algorithms.



%On one hand, programmers prefer to use the more familiar programming language. 
%On the other hand, software architects, working at higher levels of abstraction, favor the use of models, and therefore prefer graphical languages for describing the system architecture and the high level logic behavior \cite{Hutchinson:2011:MEP:1985793.1985882,Hutchinson:2011:EAM:1985793.1985858}.
%Furthermore, a common practice in industry is to use improper languages, C++/Java e.g., to define fine-grained actions within models.
%Due to several reasons such as bug fixing or code level optimization, code is usually refined/modified after generation.


%The code modified by programmers and the model are then inconsistent. 
%This is considered as the well-known Round-trip engineering (RTE) \cite{Hettel2008} problem in MDE.
%is proposed to synchronize different software artifacts, model and code in this case \cite{Sendall}. 
%RTE enables actors (software architect and programmers) to freely move between different representations and stay efficient with their favorite working environment. 
%In other words, RTE enables both model and code to be considered as development artifact. 

%\input{sections/problemdefinition}

%\input{sections/reasons}

%\input{contributions}

%The surveys described in \cite{Hutchinson:2011:MEP:1985793.1985882} and \cite{Hutchinson:2011:EAM:1985793.12985858} polled MDE practitioners. 
%It notes that 70\% of the respondents primarily work with models, but still require manually-written code to be integrated.
%Furthermore, 35\% of the respondents answered that they spend a lot of time and effort synchronizing model and code.

%However, on the one hand, maintaining code generated from existing approaches is non-trivial. On the other hand our observation is that it is very difficult to come up with formalizations that yield such elegant code generation solutions \cite{6032552}. In other words, generated code must be manually modified to build fully operational applications. 
%On one hand there are traditional developers who prefer to implement the system by writing code, while on the other hand there are developers who prefer to use entirely models for the design and implementation of the system. 



%After code modifications, round-trip engineering (RTE) is needed to make the model and code consistent, which is a critical aspect to meet quality and performance constraint required from project managers today. 

%\input{sections/oldintroduction}

%Even though this presented work is specific to C++ and embedded systems, the general idea can be applied to other object-oriented programming languages such as Java and to other domains.

%Our contribution is summarized as followings:

%\begin{itemize}
%	\item XSeparation - code generator, mode-code synchronizer, and compiler for enabling a fluid moving between architecture and implementation.
	
%	\item Evaluations of XSeparation based on a case study.
%\end{itemize}

The contributions of this paper are as followings:
\begin{itemize}
	\item A bidirectional mapping mechanism between architecture model and code.
	
	\item A synchronization mechanism which uses the proposed mapping as a means to ease the synchronization.
	
	\item An evaluation of the approach through a case study.
\end{itemize}

This paper assumes that the readers have knowledge about component-based and UML State machine and Composite Structure concepts.

The remainder of this paper is organized as follows: Section \ref{sec:approach} describes the overview of our approach. 
The bidirectional mapping mechanism is presented in Section \ref{sec:mappingmechanism}.
Section \ref{sec:collaboration} gives the details of the synchronization mechanism.
A case study is used for evaluation of our approach in Section \ref{sec:evaluationplan}.
Section \ref{sec:discussion} openly discusses scalability and perspectives of our approach.
%Section \ref{sec:xseparationarchitecture}, \ref{sec:xseparationbehavior}, \ref{sec:collaboration}, and \ref{sec:compilation} describe the details of XSeparation including: XSeparation for architecture structure, behavior, synchronization, and compilation, respectively. %, for enabling bidirectional traceability between model and code. 
%The syntax of RAOES's front-end is detailed in Section \ref{sec:syntax}.
%Section \ref{sec:collaboration} shows how to synchronize concurrent modifications architecture model and XSeparation-generated code.
%Section \ref{sec:evaluationplan} presents our evaluation plan and preliminary experimental results. 
We discuss related work in Section \ref{sec:relatedwork}. 
The conclusion and future work are presented in Section \ref{sec:conclusion}.


