\section{XSeparation for Behavior}
\label{sec:xseparationbehavior}
This section describes the application details of XSeparation to the generation of behavior code.
The behavior of a UML component is described by a UML State Machine\footnote{It is possible to have several UML State Machines for modeling the behavior within a component but for simplication, we consider only one.}.

\input{sections/remindusm}





\subsection{Application of XSeparation for UML State Machine}
XSeparation generates and synchronizes \tb{Behavior-prescribed code} and \tb{State machine action code} from UML State Machines describing the behavior of a component.
As previously discussed, one of the main issues that hinders the synchronization of UML State Machines and code is the lack of mapping between these artifacts.
Applying XSeparation to UML State Machines, code generated by XSeparation is at the right abstraction level, which contains additional constructs for state machines for tracing from the code back to the model.
 
Back to the UML State Machine example in Fig. \ref{fig:fifostatemachine} for illustration, XSeparation generates code as in Listing \ref{lst:fifostatemachine}.
The \tb{Behavior-prescribed code} is divided into three parts: topology, events, and transition table, which are described in the belows.




\vskip 0.2cm
\noindent
\tb{Topology:}
A topology describes the hierarchical structure of a UML State Machine in generated code.
As the example in Listing \ref{lst:fifostatemachine}, the root of the topology is define by \ttt{state\_machine}.
Other elements such as \ttt{region}, \ttt{state}, and \ttt{pseudo state} are defined as sub-elements.
The followings give the syntax of some elements in the generated code and the semantics mapped to the well-defined semantics in the UML specification \cite{OMG2015}.


\begin{minipage}{0.95\columnwidth}
	\lstinputlisting[language=C++, caption={Code generated from the FIFO State Machine}, label=lst:fifostatemachine,frame=f]{code/fifostatemachine.cpp}
\end{minipage}

\subsubsection{State and regions} ~\\
\indent
\tb{Syntax:}
\begin{itemize}[\footnotesize]
	\item \ti{state machine} $\rightarrow$ \tf{'Statemachine' name \{subvertices\}';'} 
	
	\item \ti{state} $\rightarrow$ \tf{'State' \{state\_action\}; subvertices}
	
	\item \ti{state} $\rightarrow$ \tf{'InitialState' name \{state\_action;effect?;subvertices\}}
	
	\item \ti{concurrent state} $\rightarrow$ \tf{'State' name \{state\_action; regions\}}
	
	\item \ti{regions} $\rightarrow$ \tf{region; regions}
	
	\item \ti{region} $\rightarrow$ \tf{'Region' name \{ subvertices \};}
	
	\item \ti{state\_action} $\rightarrow$ \tf{'StateEntry/StateExit/StateDoActivity' actionName}
	
	\item \ti{subvertices} $\rightarrow$ \tf{state/concurrent state/pseudo state; subvertices}
	
	\item \ti{effect} $\rightarrow$ \tf{'TransitionEffect' effName;} 
	
	%\item \ti{deferred event} $\rightarrow$ \tf{'defer(' eventId ');'}
\end{itemize}

\tb{Semantics:}
\begin{itemize}
	\item \ttt{name}: the unique identifier of a state machine, a state, or a region.
	
	\item \ttt{actionName}: The name of the entry/exit/doActivity action method of the state. 
	This method is implemented in the corresponding class, whose behavior is described by the state machine, and has no parameter.
	%If a state does not have an entry/exit action, \ttt{ent/ex} becomes \ttt{NULL}.
	
	\item \ttt{initial\_state}: A state is defined as an initial state, which has an incoming transition outgoing from a pseudo initial state within the same region or composite state. 
	
	\item \ttt{effName}: For initial state, this is the transition effect associated with the initial transition.
	%If the latter does not have an effect, \ttt{effect} is specified as \ttt{NULL}.
	
	\item \ttt{concurrent state}: The representation of a concurrent state. 
	The latter is composed of a set of regions.
	Each region contains a set of vertices, which for each is either a state or a pseudo state.
	
	%\item \ttt{eventId}: The identifier of a defined event (see \ref{subsec:events}), which is deferred by the corresponding state. 
\end{itemize}


\tb{Example:}
Lines 6-35 in Listing \ref{lst:fifostatemachine} shows the code generated from the FIFO UML State Machine Fig. \ref{fig:fifostatemachine}.
\ttt{Idle} is defined as the initial state. 
The \ttt{SignalChecking} and \ttt{ErrorNotification} states (lines 8-14) are declared with methods written the \tb{State machine action code} part following the \tb{BP-U Agreement} for state. The latter is specified as following: the entry/exit/doActivity action of a state, if declared within the topology, must be implemented as a method of the component/class. 
For example, \ttt{entryCheck}, \ttt{exitCheck}, and \ttt{entryError} are implemented in the component class FIFO (lines 37-46).

\subsubsection{Pseudo state} ~\\
\indent
\tb{Syntax:}
Pseudo states have similar syntax as below.
In this latter, \ttt{pseudo\_keyword} type is one of \ttt{\{PseudoEntryPoint, PseudoExitPoint, PseudoInitial, PseudJoin, PseudoFork, PseudoChoice, PseudoJunction, PseudoShallowHistory, PseudoDeepHistory, PseudoTerminate\}}, which correspond to the pseudo states defined in UML State Machine. 
\ttt{name} is the unique name of the pseudo state.

\begin{itemize}[\footnotesize]
	\item \ti{pseudo state} $\rightarrow$ \tf{'pseudo\_keyword' name} 
	%\item \ti{entry point} $\rightarrow$ \tf{'entry\_point ('name');'} 
	
	%\item \ti{exit point} $\rightarrow$ \tf{'exit\_point ('name');'}
	
	%\item \ti{initial} $\rightarrow$ \tf{'initial ('name');'}
	
	%\item \ti{final} $\rightarrow$ \tf{'final\_state ('name');'}
	
	%\item \ti{join} $\rightarrow$ \tf{'join ('name');'}
	
	%\item \ti{fork} $\rightarrow$ \tf{'fork ('name');'}
	
	%\item \ti{choice} $\rightarrow$ \tf{'choice ('name');'}
	
	%\item \ti{junction} $\rightarrow$ \tf{'junction ('name');'}
	
	%\item \ti{shallow history} $\rightarrow$ \tf{'shallow\_history ('name');'}
	
	%\item \ti{deep history} $\rightarrow$ \tf{'deep\_history ('name');'}
\end{itemize}

\tb{Example:}
\ttt{PseudoChoice(dataChoice)} and \ttt{PseudoChoice(queueChoice)} in Listing \ref{lst:fifostatemachine} represent the generated code for two \ttt{choice} pseudo states in the FIFO UML State Machine example.  

\vskip 0.2cm
\noindent
\tb{Events:}
UML State Machine specifies four event types: \ttt{CallEvent}, \ttt{TimeEvent}, \ttt{SignalEvent}, \ttt{ChangeEvent}. The code generated by XSeparation for these events has syntax as followings:
\begin{itemize}[\footnotesize]
	\item \ttt{CallEvent} $\rightarrow$ \tf{'CallEvent'} \tf{'('name, op');'}
	
	\item \ttt{TimeEvent} $\rightarrow$ \tf{'TimeEvent'} \tf{'('name, dur');'}
	
	\item \ttt{SignalEvent} $\rightarrow$ \tf{'SignalEvent'<sig> name}
	
	\item \ttt{ChangeEvent} $\rightarrow$ \tf{'ChangeEvent'} \tf{'('name, expr');'}
\end{itemize}


\tb{Semantics:}
Essentially, each field in the syntax carries known semantics defined in the UML specification.
\begin{description}
	\item[\ttt{name}] The unique identifier for an event.
	
	\item[\ttt{op}] The name of the operation associated with a \ttt{CallEvent} and implemented in the active class. 
	
	\item[\ttt{dur}] The duration associated with a \ttt{TimeEvent} and specified as millisecond.
	
	\item[\ttt{sig}] The name of the signal class type (a UML signal is transformed into an object-oriented class) associated with a \ttt{SignalEvent}.
	
	\item[\ttt{expr}] The expression associated with a \ttt{ChangeEvent}. This expression is periodically evaluated to check whether its boolean value is changed.
\end{description}

%\ttt{SimpleEvent} is a specialized \ttt{SignalEvent} without specifying an explicit signal.
%It is not explicitly standardized by UML but provided by tools such as QM \cite{qm} for practical reasons. 


%A \ttt{CallEvent} occurs if the method \ttt{method1} in the active class is called.
%\ttt{signal\_event(SE, Sig)}: A \ttt{SignalEvent} occurs if an instance of \ttt{Sig} is sent to the active class using its provided method \ttt{sendSig}.
%\ttt{time\_event(TE5ms, 5)}: A \ttt{TimeEvent} occurs after 5 millisecond from the moment the timer starts by entering some state.

\vskip 0.2cm
\noindent
\tb{Transition table:}
There are three kinds of UML transitions: \ttt{external}, \ttt{local}, and \ttt{internal}.

\tb{Syntax:}
\begin{itemize}[\footnotesize]
	%\noindent
	\item \ttt{external} $\rightarrow$ \tf{'Transition'} \tf{'('src, tgt, guard, evt, eff');'}
	
	%\noindent
	\item \ttt{local}$\rightarrow$\tf{'LocalTransition}\tf{('src,tgt,guard,evt,eff');'}
	
	%\noindent
	\item \ttt{internal} $\rightarrow$ \tf{'IntTransition}\tf{('src, guard, evt, eff');'}
\end{itemize}


\tb{Semantics:}
\begin{description}
	\item[\ttt{src/tgt}] The name of the source/target vertex of the transition. 
	This name must be defined in the topology.
	
	%\item[\ttt{tgt}] The name of the target vertex of the transition. 
	
	\item[\ttt{guard}] A boolean expression representing the transition's guard and NULL If the transition is not guarded.
	
	\item[\ttt{evt}] The name of the event triggering the transition. 
	\tf{evt} must be one of the defined events as above or NULL if the transition is not associated with any event.
	
	\item[\ttt{eff}] The name of the method, which defines the effect of the transition or NULL if the transition has no effect.
	For \tb{BP\_U Agreement}, this method must be implemented by the component.
	If \ttt{evt} is a \ttt{SignalEvent}, the method has an input parameter typed as the signal class associated with the event.
	If \ttt{evt} is a \ttt{CallEvent}, the method has the same formal parameters as the method associated with \ttt{evt}.
\end{description}


\tb{Example:} \ttt{CallEvent(DataPushEvent, push)} at line 22 of Listing \ref{lst:fifostatemachine} specifies that an event is fired whenever the \ttt{push} method, which is implemented by \ttt{FIFO} for the \ttt{IPush} interface provided by the \ttt{pPush} port, is invoked.
The event firing activates the transition from \ttt{Idle} to \ttt{SignalChecking} and executes the \ttt{signalCheckingEffect} method associated with the transition if the current active state is \ttt{Idle}.
If so, the data item brought by the invocation will be checked for validity and further put to the queue or discarded.
Note that \ttt{signalCheckingEffect} has the same formal parameters with the \ttt{push} method.

State machines generated by XSeparation will be compiled to executable files by using our XSeparation compiler, which is presented in Section \ref{sec:compilation}.
The executable files run in an asynchronous mode, in which according to UML State Machine, events, except CallEvent, are stored in an event queue.
Furthermore, the boolean expression of ChangeEvent is periodically evaluated.
The size of the event queue and the periodic evaluation time can be configured within the topology of the state machines.
Lines 31-34 in Listing \ref{lst:fifostatemachine} configures the size of the queue as 50 and the periodic evaluation time is 20 millisecond.
Note that this configuration is different from the structure configuration, which is used for wiring different components through explicitly defined ports.

In the next section, we will show how to synchronize the XSeparation-generated code with the architecture model in case of concurrent modifications. 
%discussion with data port and signal events..



%\noindent
%\tb{Example:}
%\begin{itemize}[\footnotesize]
%	\item \ttt{transition(S1,S2,guard1,CE1,effect1)}: A transition from \ttt{S1} to \ttt{S2} which is fired if there is an appeal to the method \ttt{method1} and the value of \ttt{guard1} is true.
%	\ttt{method1} is associated with the \ttt{CallEvent CE1} as the example above.
%	Furthermore, an action \ttt{effect1} is executed when the transition fires.
%	Listing \ref{lst:effect-segment} shows how to write \ttt{effect1} (lines 4-6) corresponding to the signature of \ttt{method1} (line 1-3) following the above semantics.
	
%	\item \ttt{transition(S11,S2,NULL,SE,effect2)}: A transition, triggered by the signal event \ttt{SE}, executing \ttt{effect2}.
%	\ttt{effect2} in Listing \ref{lst:effect-segment} has a parameter typed by signal \ttt{Sig} associated with the event \ttt{SE}.
%\end{itemize}

\begin{comment}{1.05\columnwidth}
	\begin{lstlisting}[language=C++, caption=A segment of C++ front-end code, label=lst:effect-segment,frame=f]
	void method1(int p1, int p2) {
	//method1 body
	}
	void effect1(int p1, int p2) {
	//effect1 body
	}
	void effect2(Sig& s) {
	//effect2 body
	}
	\end{lstlisting}
\end{comment}





