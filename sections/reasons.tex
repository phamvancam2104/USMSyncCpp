\subsection{Why is it a problem? Why are there concurrent modifications?}
\label{subsec:reasons}

\noindent
\circled{1} \tb{Architecture and implementation abstraction gap}
\begin{itemize}
	\item It is frequently that programmers modify architecture information during implementation. %It is not easy to preserve the architecture correctness in implementation. 
	Current industrial MDE settings put fine-grained behaviors/computational algorithms directly in the architecture model to generate full code. 
	However, it is %difficult for system analysis and 
	not favorable because the architecture should only hold design decisions. 
	Hence, code generated from the current MDE tools must be tailored by programmers for fine-grained code.
	In this case, the architecture correctness might be violated, which is not easy to detect due to the lack of a bidirectional traceability between the architecture and code \cite{ubayashi2010archface}.
	
	%\item A common practice in industry is to use improper languages, C++/Java e.g., to define fine-grained actions within models. 
	
	
	\item In software evolution, continuous development and maintenance, the architects might change the architecture for new functionalities or requirements while the programmers might still implement the current architecture or modify the code for various reasons such as code level optimization, bug fixing, refactoring. 
	In MDE tools, the regeneration of code from the changed architecture would overwrite the modifications made by programmers in code. 
	Some tools such as Eclipse Modeling Framework (EMF) \cite{steinberg2008emf} separate code areas, which could be modified by the programmers, to preserve the code changes by using some specialized comments such as \ttt{@generated NOT}.
	However, current separation mechanisms require the programmers to be highly discipline.
	Furthermore, even so, accidental changes are still possible \cite{zheng2012enhancing}.
	The \ttt{1.x-way architecture mapping deep separation} approach \cite{zheng2012enhancing} overcome the limitations of these separation mechanisms by generating \ttt{architecture-prescribed code} in a class separating from user-code written in an other class.
	However, deep separation does not allow to modify the architecture at the code level.
	%However, code generated by these tools produce laborious comments which make the code ugly and the programmers feel hard to read and modify. 
\end{itemize} 


%However, the violation in the code is not esy to detect because there is no traceability between architecture and implementation => we need a bidirectional traceability between architecture and implementation. Unfortunately, current MDD tools are insufficient to realize this kind of bidirectional traceability.


%\vskip 0.03in
%\noindent
%\circled{2} \tb{Continuous and concurrent development and maintenance:}
%Why code modifications?
%Code level optimization, bug fixing, refactoring (renaming, i.e.)

%Architecture is not realistic in programming

%Programmers do not only modify method bodies, but also structure, methods to adopt well-known programming paradigm

%Rarely, the programmers do not change anything in architecture, if changes onccur, they have to be propagated back to the architecture




\vskip 0.03in
\noindent
\circled{2}\tb{Architecture and programmer perception}
\begin{itemize}
	\item Working with code is easier for programmers in solving computational/algorithmic problems than with models.
	
	\item Software architects, working at a high level abstract, prefer using graphic-based modeling languages for architecture and logic behavior (via UML State Machine) description.
	
	\item Programmers favor the use of text-based programming languages with their preferred integrated development environment for fine-grained statements and computational algorithms.
\end{itemize}

