\section{Preliminary evaluation results and plan}
\label{sec:evaluationplan}
The mapping is used in the implementation of our model-code synchronization tool \cite{foster2016}, which is an extension of the Papyrus modeling tool \cite{gerard201019}.
We show our preliminary results and plan to evaluate our approach in combination with our synchronization methodological pattern presented in \cite{foster2016}.

%\vskip 0.1cm
\noindent
\tb{Correctness:}
We evaluate the correctness of the synchronization of architecture model and code using our proposed mapping.
Three cases are planned: (1) can the intermediate code and mapping be used to reconstruct the original architecture model? (2) if the intermediate code is modified, can the modifications made be propagated back to the model? and (3) if both intermediate code and model are concurrently modified, can the mapping be used for synchronization?

%\vskip 0.1cm
\noindent
\tb{Semantic-conformance:}
The motivation is to evaluate the preservation of semantics of UML in the standard code.
The precise semantics of UML State Machine is defined by the Precise Semantics of UML State Machine (PSSM) \cite{PSSM} standardized by OMG with a test suite consisting 66 test cases.
62 out of 66 cases passed.
There remains for future some special cases containing, for example, a transition from an entry point to an exit point, failing.


%\vskip 0.1cm
\noindent
\tb{Standard code efficiency:}
We target event-driven embedded systems, which are resource-constrained.
Hence, event processing performance and memory usage are critical.
We compare the efficiency of the standard code with the standard code generated by UML tools such as Rhapsody and source code libraries.
The results show that the standard code in our approach runs fast and requires little memory.

%\vskip 0.1cm
\noindent
\tb{Feasibility and scalability:}
We plan to use the mapping with our synchronization approach to develop a case study, which is an embedded software for LEGO.
The mapping and synchronization are feasible and scalable if the development is efficiently successful.

%Our research questions are as followings:
%\begin{description}[\footnotesize]
%	\item[\tb{RQ1}] A state machine \ttt{sm} is used for generating the front-end code. The latter is reversed engineered to produce another state machine \ttt{sm'}. Are \ttt{sm} and \ttt{sm'} identical? In other words: whether the front-end code generated from USMs model can be used for reconstructing the original model. This question is related to the \ti{GETPUT} law defined in \cite{foster_combinators_2007}.
	
%	\item[\tb{RQ2}] The back-end code is used for compilation. 
%	Does the runtime execution of the back-end code is semantic-conformant to Precise Semantics for UML State Machines (PSSM)? 
	
%	\item[\tb{RQ3}] Runtime performance and memory usage is undoubtedly critical in real-time and embedded systems. Particularly, in event-driven systems, the performance is measured by event processing speed. Does code generated by the presented approach outperform existing approaches and use less memory?
%\end{description} 