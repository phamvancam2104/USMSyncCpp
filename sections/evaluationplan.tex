\section{Preliminary evaluation results and plan}
\label{sec:evaluationplan}
The mapping is used in the implementation of our model-code synchronization tool \cite{foster2016} as an extension of Papyrus \cite{gerard201019}.
This section shows our preliminary results and plan to evaluate our approach in combination with our synchronization \cite{foster2016}.

%\vskip 0.1cm
\noindent
\tb{Correctness:}
We will evaluate the correctness of the synchronization of architecture model and code using our proposed mapping.
Three cases are planned: (1) can the extended code and mapping be used to reconstruct the original architecture model? (2) if the extended code is modified, can the modifications made be propagated back to the model? and (3) if both extended code and model are concurrently modified, can the mapping be used for synchronization?

%\vskip 0.1cm
\noindent
\tb{Semantic-conformance:}
The motivation is to assess the preservation of semantics of UML in the code.
In \cite{fullusm}, we show our experiments to test the runtime execution of the code against the precise semantics of UML State Machine standardized by OMG in \cite{PSSM} with a test suite consisting 66 test cases.
62 out of 66 cases passed leaving for future to fix failed test cases.


%\vskip 0.1cm
\noindent
\tb{Standard code efficiency:}
We target resource-constrained embedded systems.
Hence, event processing speed and memory usage are critical.
We compare the efficiency of the generated code with the code generated by some UML tools and source code libraries in \cite{fullusm}.
The results show that the code in our approach runs fast and requires little memory.

%\vskip 0.1cm
\noindent
\tb{Feasibility and scalability:}
We plan to use the mapping with our synchronization approach to develop a case study, which is an embedded software for LEGO.
The mapping and synchronization are feasible and scalable if efficient development is possible.

%Our research questions are as followings:
%\begin{description}[\footnotesize]
%	\item[\tb{RQ1}] A state machine \ttt{sm} is used for generating the front-end code. The latter is reversed engineered to produce another state machine \ttt{sm'}. Are \ttt{sm} and \ttt{sm'} identical? In other words: whether the front-end code generated from USMs model can be used for reconstructing the original model. This question is related to the \ti{GETPUT} law defined in \cite{foster_combinators_2007}.
	
%	\item[\tb{RQ2}] The back-end code is used for compilation. 
%	Does the runtime execution of the back-end code is semantic-conformant to Precise Semantics for UML State Machines (PSSM)? 
	
%	\item[\tb{RQ3}] Runtime performance and memory usage is undoubtedly critical in real-time and embedded systems. Particularly, in event-driven systems, the performance is measured by event processing speed. Does code generated by the presented approach outperform existing approaches and use less memory?
%\end{description} 