\section{Conclusion}
\label{sec:conclusion}
We have presented an approach for synchronization of object-oriented programming code and architecture model specified in using UML Class, Composite Structure and State Machine concepts, notable components, ports, connectors, and state machine elements.
The approach is based on extending an existing object-oriented programming language by introducing additional ad-hoc programming constructs for modeling concepts that have no representation in common programming languages such as Java and C++.
The extended code written with the additional constructs is used as input of an in-place text-to-text transformation to generate other code files to be executable.
The synchronization mechanism synchronizes the extended code with the model in case of concurrent modifications.

%bidirectional mapping between code and architecture model specified by UML class, composite structure, and state machine diagrams.
%a round-trip engineering approach for effective collaboration between software architects and programmers in developing and maintaining reactive embedded systems using UML State Machines for describing behaviors. 
%The design for concurrency of generated code is based on multi-thread.
%The code generation pattern set extends the IF-ELSE/SWITCH patterns and the state pattern extension. 
%The hierarchy of USM is kept by our simple state structure.


%We successfully applied XSeparation to the development of a case study.
%The latter is an software application for LEGO.
  
To evaluate the correctness, the practicality, and the feasibility of the synchronization, we used the approach to develop an embedded software case study - Lego Car factory.
Our approach can synchronize concurrent modifications in model and code.
Furthermore, the quality of generated code is also preserved in the synchronization approach, in compared to the approach without synchronization.
We also discuss the applicability and scalability of our approach in applying it to distributed architectures, synchronization of ALF and programming languages for profiting advantages of both of the modeling and programming world.  

The main limitation of our approach is the applicability to the synchronization of architecture model with different programming languages.
For the moment, the approach is applicable to C++ and Java.
In future, we will investigate other programming languages. 
The discussed perspectives will also be further detailed for elaborating our approach.  
%Furthermore, we will apply our approach to other programming languages such as Java and C\# and investigate how this work may scale on modern architectures. 
%\lipsum[1-2] 
%RAOES introduces a C++ front-end code lying between models and actual executable code.
%RAOES proposes a framework for synchronizing the models and the front-end code, and generating executable code from the front-end.
%RAOES is implemented as an extension of the Papyrus modeling tool.

%We evaluated RAOES by conducting experiments on the round-trip engineering correctness, the semantic-conformance and efficiency of generated code, and by implementing a case study simulation of a Traffic Light Controller.
%300 random models are tested for the RTE correctness.
%The conformance is tested under PSSM: 62/66 tests pass.
%The efficiency of back-end code has been evaluated, RAOES produces code that runs faster in event processing time and is smaller in executable size than those of other approaches (in the paper's scope).

%Although RAOES does not deal with extraction of information from existing/legacy code, the latter can still be reused by RAOES in two ways: (1) reverse engineering from the legacy code to a model, which can be manipulated further by architects, or (2) directly integrating the legacy code by programmers into front-end code. 
%Furthermore, RAOES allows to work abstractly by using models and in a low-level way by using front-end code concurrently and simultaneously. Hence, RAOES is effective in software development, evolution, collaboration, and maintenance by using our synchronization process.


%For the moment, RAOES supports the co-evolution of UML class and state machine diagrams and code.
%In the future, we will integrate component-based concepts into C++ to make the front-end more powerful and effective.
%Our wish is to embed component-connector and interaction component information represented in UML composite structure diagrams into C++ to elaborate the application range such as distributed embedded systems.
%A possible direction to this integration is to extend \ttt{nesc} \cite{gay2003nesc} - an extension of the C language dedicated component-based development of networked applications.
%However, code produced by PSM consumes slightly more memory than the others.
%Furthermore, some PSSM tests are failed.
%Therefore, as a future work, we will fix these issues by making multi-thread part of generated code more concise.  
 