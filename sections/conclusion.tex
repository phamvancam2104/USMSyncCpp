\section{Conclusion}
\label{sec:conclusion}
We have presented a bidirectional mapping between code and architecture model specified by UML class, composite structure, and state machine diagrams.
%a round-trip engineering approach for effective collaboration between software architects and programmers in developing and maintaining reactive embedded systems using UML State Machines for describing behaviors. 
%The design for concurrency of generated code is based on multi-thread.
%The code generation pattern set extends the IF-ELSE/SWITCH patterns and the state pattern extension. 
%The hierarchy of USM is kept by our simple state structure.
%XSeparation code generation improves the bidirectional traceability between architecture model and code by proposing to generate code at an appropriate level of abstraction. 
The idea is to raise the abstraction level of an existing object-oriented programming language in order to reduce the semantic gap between modeling and coding.
The aim of the approach is to use the mapping as input in our model-code synchronization mechanism presented in \cite{foster2016}.
%An XSeparation compiler was developed to compile the XSeparation-generated code.
%XSeparation is implemented as an extension of the Papyrus modeling tool for the case of UML and C++. 

%We successfully applied XSeparation to the development of a case study.
%The latter is an software application for LEGO.
  

For the moment, the approach is implemented for UML and C++.
In the future, we will extensively evaluate the approach for different aspects: synchronization correctness, feasibility, and scalability. 
 
%\lipsum[1-2] 
%RAOES introduces a C++ front-end code lying between models and actual executable code.
%RAOES proposes a framework for synchronizing the models and the front-end code, and generating executable code from the front-end.
%RAOES is implemented as an extension of the Papyrus modeling tool.

%We evaluated RAOES by conducting experiments on the round-trip engineering correctness, the semantic-conformance and efficiency of generated code, and by implementing a case study simulation of a Traffic Light Controller.
%300 random models are tested for the RTE correctness.
%The conformance is tested under PSSM: 62/66 tests pass.
%The efficiency of back-end code has been evaluated, RAOES produces code that runs faster in event processing time and is smaller in executable size than those of other approaches (in the paper's scope).

%Although RAOES does not deal with extraction of information from existing/legacy code, the latter can still be reused by RAOES in two ways: (1) reverse engineering from the legacy code to a model, which can be manipulated further by architects, or (2) directly integrating the legacy code by programmers into front-end code. 
%Furthermore, RAOES allows to work abstractly by using models and in a low-level way by using front-end code concurrently and simultaneously. Hence, RAOES is effective in software development, evolution, collaboration, and maintenance by using our synchronization process.


%For the moment, RAOES supports the co-evolution of UML class and state machine diagrams and code.
%In the future, we will integrate component-based concepts into C++ to make the front-end more powerful and effective.
%Our wish is to embed component-connector and interaction component information represented in UML composite structure diagrams into C++ to elaborate the application range such as distributed embedded systems.
%A possible direction to this integration is to extend \ttt{nesc} \cite{gay2003nesc} - an extension of the C language dedicated component-based development of networked applications.
%However, code produced by PSM consumes slightly more memory than the others.
%Furthermore, some PSSM tests are failed.
%Therefore, as a future work, we will fix these issues by making multi-thread part of generated code more concise.  
 